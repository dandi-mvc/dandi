import { AsyncMutexLockAlreadyReleasedError } from './async-mutex-lock-already-released-error'
import { AlreadyDisposedError, Disposable } from './disposable'
import { globalSymbol } from './global.symbol'

const RELEASED = globalSymbol('AsyncMutex.RELEASED')

/**
 * A reference to an object instance locked by {@see AsyncMutex}
 */
export type LockedObject<T> = T & Disposable

function lockedObject<T extends object>(obj: T, released: Promise<void>, dispose: () => void): LockedObject<T> {
  return Object.defineProperties(Object.create(obj), {
    [RELEASED]: {
      value: released,
      configurable: false,
      writable: false,
    },
    dispose: {
      value: dispose,
      configurable: false,
      writable: false,
    },
  })
}

function throwAlreadyReleased(): never {
  throw new AsyncMutexLockAlreadyReleasedError()
}

const MUTEXES = new Map<any, AsyncMutex<any>>()
const DISPOSED_ERROR = 'The lock request was rejected because the underlying mutex was disposed'

/**
 * A `mutex` (mutual exclusion object) implementation that allows controlled asynchronous access to a resource.
 *
 * Use [[AsyncMutex.for]] to create a "locked" version of a source. It is recommended that the resource is not made
 * accessible through any means (instance properties, etc) to avoid accidental unlocked access.
 *
 * Only one {@see AsyncMutex} instance will be created per resource instance, ensuring that the underlying resource can be
 * shared between multiple consuming instances without crossing the streams. As such, it is important that each
 * consuming instance implements {@see Disposable} and calls [[AsyncMutex.dispose]] at the end if its lifecycle to avoid
 * leaking the {@see AsyncMutex} instance.
 *
 * Note that resources that implement {@see Disposable} themselves will be automatically disposed when the {@see AsyncMutex}
 * instance is disposed. Calling {@see dispose} on {@see LockedObject} instances generated by the mutex will _not_ dispose
 * of the underlying resource.
 *
 * ```typescript
 * class MutexConsumer implements Disposable {
 *
 *   private lockedResource: AsyncMutex<ContentiousResource>
 *
 *   constructor(myResource: ContentiousResource) {
 *     this.lockedResource = AsyncMutex.for(myResource)
 *   }
 *
 *   public async doSomething(query: string): Promise<void> {
 *     await this.lockedResource.runLocked(async (resource: ContentiousResource) => {
 *       await resource.execute(query)
 *     })
 *   }
 *
 *   public async dispose(reason: string): Promise<void> {
 *     await this.lockedResource.dispose(reason)
 *     Disposable.remapDisposed(this, reason)
 *   }
 *
 * }
 * ```
 *
 * @typeparam T The type of locked resource
 */
export class AsyncMutex<T extends object> implements Disposable {

  /**
   * Constructs an {@see AsyncMutex} instance for the specified object. Only one {@see AsyncMutex} instance will be created
   * per object, ensuring that `obj` can be shared between multiple consumers without crossing the streams.
   *
   * @typeparam T The type of object to lock
   * @param obj The object to lock
   */
  public static for<T extends object>(obj: T): AsyncMutex<T> {
    let mutex = MUTEXES.get(obj)
    if (!mutex) {
      mutex = new AsyncMutex(obj)
      MUTEXES.set(obj, mutex)
    }
    return mutex
  }

  private locks = []

  /**
   * @param lockObject The resource that will be locked
   */
  private constructor(private lockObject: T) {
    if (!this.lockObject) {
      throw new Error('An lockObject must be specified')
    }
  }

  /**
   * Requests a lock using {@see getLock}, then uses [[Disposable.useAsync]] with the resulting {@see LockedObject} to execute
   * `fn`, and then release/dispose the lock.
   * @param fn
   */
  public async runLocked<TResult>(fn: (lock?: LockedObject<T>) => Promise<TResult>) {
    return Disposable.useAsync(this.getLock(), fn)
  }

  /**
   * Returns a promise that resolves to a {@see LockedObject} instance once there are no preceding lock requests in
   * the queue. The fulfilled {@see LockedObject} instance must be disposed in order to release the lock. If `T`
   * implements {@see Disposable}, disposing {@see LockedObject} will _not_ dispose the underlying resource.
   */
  public async getLock(): Promise<LockedObject<T>> {
    let release: Function
    const released = new Promise<void>(resolve => release = resolve)
    const lock = lockedObject<T>(this.lockObject, released, () => {
      if (release) {
        if (this.locks[0] !== lock) {
          throw new Error('should not happen!')
        }
        this.locks.shift()
        for (const prop of Object.getOwnPropertyNames(Object.getPrototypeOf(this.lockObject))) {
          if (prop === 'constructor' || prop === 'dispose') {
            continue
          }
          Object.defineProperty(lock, prop, {
            get: throwAlreadyReleased,
            configurable: false,
          })
        }
        release()
        release = undefined
      }
    })
    const prevLock = this.locks[this.locks.length - 1]
    this.locks.push(lock)
    if (prevLock) {
      await prevLock[RELEASED]
    }
    if (Disposable.isDisposed(this)) {
      throw new AlreadyDisposedError(this, `${DISPOSED_ERROR}: ${Disposable.getDisposedReason(this)}`)
    }
    return lock
  }

  public async dispose(reason: string): Promise<void> {
    MUTEXES.delete(this.lockObject)
    if (Disposable.isDisposable(this.lockObject) && !Disposable.isDisposed(this.lockObject)) {
      await this.lockObject.dispose(reason)
    }
    Disposable.remapDisposed(this, reason)
  }

}
